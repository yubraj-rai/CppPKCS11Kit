#include "gtest/gtest.h"
#include "core/crypto_manager.hpp"
#include "utils/hex_utils.hpp"
#include "app_config.h" // Generated by CMake

#include <random> // For IV generation
#include <chrono> // For unique IDs (nanoseconds)
#include <thread> // For std::this_thread::get_id()
#include <sstream> // For std::stringstream in generate_unique_id

// Helper function to convert std::string to std::vector<CK_BYTE>
std::vector<CK_BYTE> string_to_ckbyte_vec(const std::string& s) {
    return std::vector<CK_BYTE>(s.begin(), s.end());
}

// Function to generate a random Initialization Vector (IV) for AES
std::vector<CK_BYTE> generate_random_iv(size_t length) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::vector<CK_BYTE> iv(length);
    for (size_t i = 0; i < length; ++i) {
        iv[i] = static_cast<CK_BYTE>(gen() % 256); // Generate random byte
    }
    return iv;
}

// Test Fixture for CryptoManager
class CryptoTestFixture : public ::testing::Test {
protected:
    // Static members for resources shared across all tests (but initialized once)
    static crypto::CryptoManager* s_manager;
    static CK_SLOT_ID s_slot_id;

    // Per-test setup (runs before each test in this fixture)
    void SetUp() override {
        // Ensure manager and slot_id are initialized once for all tests
        if (!s_manager) {
            try {
                s_manager = new crypto::CryptoManager(PKCS11_LIB_PATH, USER_PIN);
                s_slot_id = s_manager->get_first_slot_id();
            } catch (const std::exception& e) {
                FAIL() << "Failed to initialize CryptoManager or get slot ID: " << e.what();
            }
        }
    }

    // Per-test teardown (runs after each test in this fixture)
    void TearDown() override {
        // Close thread-local session after each test to ensure clean state for next test
        if (s_manager) {
            s_manager->close_thread_local_session();
        }
    }

    // Static teardown for all tests in this test suite (runs once after all tests in fixture are done)
    // This is called automatically by Google Test, so it must be public or protected static.
    // No need to call it manually from main.
    static void TearDownTestSuite() {
        // Clean up the CryptoManager instance
        if (s_manager) {
            delete s_manager;
            s_manager = nullptr;
        }
    }

    // Helper to generate unique IDs for keys within a test
    std::vector<CK_BYTE> generate_unique_id(const std::string& prefix) {
        auto now = std::chrono::high_resolution_clock::now();
        auto nanos = std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch()).count();
        std::stringstream ss;
        ss << prefix << "_" << nanos << "_" << std::this_thread::get_id(); 
        return string_to_ckbyte_vec(ss.str());
    }
};

// Initialize static members
crypto::CryptoManager* CryptoTestFixture::s_manager = nullptr;
CK_SLOT_ID CryptoTestFixture::s_slot_id = CK_INVALID_HANDLE;

// --- Test Cases ---

TEST_F(CryptoTestFixture, CryptoManagerInitialization) {
    ASSERT_NE(s_manager, nullptr) << "CryptoManager should be initialized.";
    ASSERT_NE(s_slot_id, CK_INVALID_HANDLE) << "Slot ID should be valid.";
}

TEST_F(CryptoTestFixture, RSAKeyPairGenerationAndCleanup) {
    std::vector<CK_BYTE> pub_id = generate_unique_id("test_rsa_pub");
    std::vector<CK_BYTE> priv_id = generate_unique_id("test_rsa_priv");

    CK_OBJECT_HANDLE hPublicKey = CK_INVALID_HANDLE;
    CK_OBJECT_HANDLE hPrivateKey = CK_INVALID_HANDLE;

    // Generate Key Pair
    ASSERT_NO_THROW({
        auto key_pair = s_manager->generate_rsa_key_pair_on_token(s_slot_id, pub_id, priv_id, 2048);
        hPublicKey = key_pair.first;
        hPrivateKey = key_pair.second;
    });

    ASSERT_NE(hPublicKey, CK_INVALID_HANDLE) << "Public key handle should be valid.";
    ASSERT_NE(hPrivateKey, CK_INVALID_HANDLE) << "Private key handle should be valid.";

    // Verify keys exist
    ASSERT_NE(s_manager->find_object_by_id(s_slot_id, pub_id), CK_INVALID_HANDLE) << "Public key should be findable by ID.";
    ASSERT_NE(s_manager->find_object_by_id(s_slot_id, priv_id), CK_INVALID_HANDLE) << "Private key should be findable by ID.";

    // Clean up
    ASSERT_NO_THROW(s_manager->destroy_object_on_token(s_slot_id, hPrivateKey));
    ASSERT_NO_THROW(s_manager->destroy_object_on_token(s_slot_id, hPublicKey));

    // Verify keys are destroyed
    ASSERT_EQ(s_manager->find_object_by_id(s_slot_id, pub_id), CK_INVALID_HANDLE) << "Public key should be destroyed.";
    ASSERT_EQ(s_manager->find_object_by_id(s_slot_id, priv_id), CK_INVALID_HANDLE) << "Private key should be destroyed.";
}

TEST_F(CryptoTestFixture, RSASignAndVerify) {
    std::vector<CK_BYTE> pub_id = generate_unique_id("test_sign_pub");
    std::vector<CK_BYTE> priv_id = generate_unique_id("test_sign_priv");
    CK_OBJECT_HANDLE hPublicKey = CK_INVALID_HANDLE;
    CK_OBJECT_HANDLE hPrivateKey = CK_INVALID_HANDLE;

    ASSERT_NO_THROW({
        auto key_pair = s_manager->generate_rsa_key_pair_on_token(s_slot_id, pub_id, priv_id, 2048);
        hPublicKey = key_pair.first;
        hPrivateKey = key_pair.second;
    });

    std::string message = "Test message for RSA signing and verification.";
    std::vector<CK_BYTE> data_to_sign(message.begin(), message.end());

    std::vector<CK_BYTE> signature;
    ASSERT_NO_THROW(signature = s_manager->sign_data_on_token(s_slot_id, hPrivateKey, data_to_sign));
    ASSERT_FALSE(signature.empty()) << "Signature should not be empty.";

    bool verified = false;
    ASSERT_NO_THROW(verified = s_manager->verify_signature_on_token(s_slot_id, hPublicKey, data_to_sign, signature));
    ASSERT_TRUE(verified) << "Signature should be valid.";

    // Test with invalid signature
    std::vector<CK_BYTE> tampered_signature = signature;
    if (!tampered_signature.empty()) {
        tampered_signature[0] ^= 0x01; // Tamper with the first byte
    }
    bool tampered_verified = true;
    ASSERT_NO_THROW(tampered_verified = s_manager->verify_signature_on_token(s_slot_id, hPublicKey, data_to_sign, tampered_signature));
    ASSERT_FALSE(tampered_verified) << "Tampered signature should be invalid.";

    // Clean up
    ASSERT_NO_THROW(s_manager->destroy_object_on_token(s_slot_id, hPrivateKey));
    ASSERT_NO_THROW(s_manager->destroy_object_on_token(s_slot_id, hPublicKey));
}

TEST_F(CryptoTestFixture, RSAEncryptAndDecrypt) {
    std::vector<CK_BYTE> pub_id = generate_unique_id("test_enc_pub");
    std::vector<CK_BYTE> priv_id = generate_unique_id("test_enc_priv");
    CK_OBJECT_HANDLE hPublicKey = CK_INVALID_HANDLE;
    CK_OBJECT_HANDLE hPrivateKey = CK_INVALID_HANDLE;

    ASSERT_NO_THROW({
        auto key_pair = s_manager->generate_rsa_key_pair_on_token(s_slot_id, pub_id, priv_id, 2048);
        hPublicKey = key_pair.first;
        hPrivateKey = key_pair.second;
    });

    std::string plaintext_str = "This is a secret message for RSA encryption. It must be short enough for RSA.";
    // Ensure plaintext is within RSA PKCS#1 v1.5 limits for 2048-bit key (245 bytes)
    if (plaintext_str.length() > 245) {
        plaintext_str = plaintext_str.substr(0, 245);
    }
    std::vector<CK_BYTE> plaintext(plaintext_str.begin(), plaintext_str.end());

    std::vector<CK_BYTE> ciphertext;
    ASSERT_NO_THROW(ciphertext = s_manager->encrypt_rsa_data_on_token(s_slot_id, hPublicKey, plaintext));
    ASSERT_FALSE(ciphertext.empty()) << "Ciphertext should not be empty.";
    ASSERT_EQ(ciphertext.size(), 2048 / 8) << "Ciphertext size should match key size for RSA.";

    std::vector<CK_BYTE> decrypted_plaintext;
    ASSERT_NO_THROW(decrypted_plaintext = s_manager->decrypt_rsa_data_on_token(s_slot_id, hPrivateKey, ciphertext));

    ASSERT_EQ(plaintext, decrypted_plaintext) << "Decrypted RSA plaintext should match original.";

    // Clean up
    ASSERT_NO_THROW(s_manager->destroy_object_on_token(s_slot_id, hPrivateKey));
    ASSERT_NO_THROW(s_manager->destroy_object_on_token(s_slot_id, hPublicKey));
}

TEST_F(CryptoTestFixture, AESKeyGenerationAndCleanup) {
    std::vector<CK_BYTE> aes_id = generate_unique_id("test_aes_key");
    CK_OBJECT_HANDLE hAesKey = CK_INVALID_HANDLE;

    ASSERT_NO_THROW(hAesKey = s_manager->generate_aes_key_on_token(s_slot_id, aes_id, 256));
    ASSERT_NE(hAesKey, CK_INVALID_HANDLE) << "AES key handle should be valid.";

    ASSERT_NE(s_manager->find_object_by_id(s_slot_id, aes_id), CK_INVALID_HANDLE) << "AES key should be findable by ID.";

    // Clean up
    ASSERT_NO_THROW(s_manager->destroy_object_on_token(s_slot_id, hAesKey));
    ASSERT_EQ(s_manager->find_object_by_id(s_slot_id, aes_id), CK_INVALID_HANDLE) << "AES key should be destroyed.";
}

TEST_F(CryptoTestFixture, AESEncryptAndDecrypt) {
    std::vector<CK_BYTE> aes_id = generate_unique_id("test_aes_enc_key");
    CK_OBJECT_HANDLE hAesKey = CK_INVALID_HANDLE;
    ASSERT_NO_THROW(hAesKey = s_manager->generate_aes_key_on_token(s_slot_id, aes_id, 256));

    std::string plaintext_str = "This is a longer secret message for AES encryption using CBC mode.";
    std::vector<CK_BYTE> plaintext(plaintext_str.begin(), plaintext_str.end());

    // Pad plaintext to a multiple of 16 bytes (AES block size) for CBC
    size_t padding_needed = 16 - (plaintext.size() % 16);
    if (padding_needed != 16) {
        plaintext.insert(plaintext.end(), padding_needed, static_cast<CK_BYTE>(padding_needed));
    }

    std::vector<CK_BYTE> iv = generate_random_iv(16); // 16-byte IV for AES CBC

    std::vector<CK_BYTE> ciphertext;
    ASSERT_NO_THROW(ciphertext = s_manager->encrypt_aes_data_on_token(s_slot_id, hAesKey, plaintext, iv));
    ASSERT_FALSE(ciphertext.empty()) << "AES ciphertext should not be empty.";
    ASSERT_EQ(ciphertext.size(), plaintext.size()) << "AES CBC ciphertext size should match padded plaintext size.";

    std::vector<CK_BYTE> decrypted_padded_plaintext;
    ASSERT_NO_THROW(decrypted_padded_plaintext = s_manager->decrypt_aes_data_on_token(s_slot_id, hAesKey, ciphertext, iv));
    ASSERT_FALSE(decrypted_padded_plaintext.empty()) << "AES decrypted plaintext should not be empty.";
    ASSERT_EQ(decrypted_padded_plaintext.size(), plaintext.size()) << "AES decrypted padded plaintext size should match original padded plaintext size.";

    // Remove PKCS#7 padding
    std::vector<CK_BYTE> decrypted_unpadded_plaintext;
    if (!decrypted_padded_plaintext.empty()) {
        CK_BYTE last_byte = decrypted_padded_plaintext.back();
        if (last_byte > 0 && last_byte <= 16 && decrypted_padded_plaintext.size() >= last_byte) {
            bool valid_padding = true;
            for (size_t i = 0; i < last_byte; ++i) {
                if (decrypted_padded_plaintext[decrypted_padded_plaintext.size() - 1 - i] != last_byte) {
                    valid_padding = false;
                    break;
                }
            }
            if (valid_padding) {
                decrypted_unpadded_plaintext.assign(decrypted_padded_plaintext.begin(), decrypted_padded_plaintext.end() - last_byte);
            } else {
                decrypted_unpadded_plaintext = decrypted_padded_plaintext; // Invalid padding, keep as is
            }
        } else {
            decrypted_unpadded_plaintext = decrypted_padded_plaintext; // No padding or invalid padding value
        }
    }

    ASSERT_EQ(string_to_ckbyte_vec(plaintext_str), decrypted_unpadded_plaintext) << "Decrypted AES plaintext should match original unpadded plaintext.";

    // Clean up
    ASSERT_NO_THROW(s_manager->destroy_object_on_token(s_slot_id, hAesKey));
}

TEST_F(CryptoTestFixture, SHA256Hashing) {
    std::string message = "This is some data to be hashed with SHA-256.";
    std::vector<CK_BYTE> data_to_hash(message.begin(), message.end());

    std::vector<CK_BYTE> hash_result;
    ASSERT_NO_THROW(hash_result = s_manager->hash_sha256_data_on_token(s_slot_id, data_to_hash));

    ASSERT_EQ(hash_result.size(), 32) << "SHA-256 hash should be 32 bytes.";
    // Known SHA-256 hash for "This is some data to be hashed with SHA-256."
    // You can generate this using an online tool or OpenSSL:
    // echo -n "This is some data to be hashed with SHA-256." | sha256sum
    std::string expected_hash_hex = "f912c9b47a96d11f26f2122614b62095f9226500411833c3066a98297f6424b8";
    ASSERT_EQ(utils::bytes_to_hex(hash_result), expected_hash_hex) << "SHA-256 hash should match expected value.";
}

// Main function for running tests
int main(int argc, char **argv) {
    // Initialize Google Test
    ::testing::InitGoogleTest(&argc, argv);

    // Run tests
    int result = RUN_ALL_TESTS();

    // Perform static teardown for the fixture
    // NO! Google Test automatically calls TearDownTestSuite() if it's static in the fixture
    // CryptoTestFixture::TearDownTestSuite(); // <-- This line caused the error

    return result;
}