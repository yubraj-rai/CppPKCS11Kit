#include "core/crypto_manager.hpp"
#include "utils/hex_utils.hpp"
#include "app_config.h" // Generated by CMake
#include <iostream>
#include <vector>
#include <string>
#include <thread>
#include <chrono> // For std::chrono::seconds
#include <numeric> // For std::iota
#include <random> // For random_device, mt19937

// Helper function to convert std::string to std::vector<CK_BYTE>
std::vector<CK_BYTE> string_to_ckbyte_vec(const std::string& s) {
    return std::vector<CK_BYTE>(s.begin(), s.end());
}

// Helper function to convert std::vector<CK_BYTE> to std::string (for display)
std::string ckbyte_vec_to_string(const std::vector<CK_BYTE>& v) {
    return std::string(v.begin(), v.end());
}

// Function to generate a random Initialization Vector (IV) for AES
std::vector<CK_BYTE> generate_random_iv(size_t length) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::vector<CK_BYTE> iv(length);
    for (size_t i = 0; i < length; ++i) {
        iv[i] = static_cast<CK_BYTE>(gen() % 256); // Generate random byte
    }
    return iv;
}


// Function to run comprehensive cryptographic operations in a thread
void run_crypto_operations(crypto::CryptoManager& manager, CK_SLOT_ID slot_id, int thread_id) {
    std::cout << "\n--- Thread " << thread_id << ": Starting comprehensive crypto operations ---" << std::endl;
    try {
        // Generate unique IDs for keys for this thread
        std::string rsa_pub_id_str = "rsa_pub_key_" + std::to_string(thread_id);
        std::string rsa_priv_id_str = "rsa_priv_key_" + std::to_string(thread_id);
        std::string aes_key_id_str = "aes_key_" + std::to_string(thread_id);

        std::vector<CK_BYTE> rsa_public_key_id = string_to_ckbyte_vec(rsa_pub_id_str);
        std::vector<CK_BYTE> rsa_private_key_id = string_to_ckbyte_vec(rsa_priv_id_str);
        std::vector<CK_BYTE> aes_key_id = string_to_ckbyte_vec(aes_key_id_str);

        CK_OBJECT_HANDLE hRsaPublicKey = CK_INVALID_HANDLE;
        CK_OBJECT_HANDLE hRsaPrivateKey = CK_INVALID_HANDLE;
        CK_OBJECT_HANDLE hAesKey = CK_INVALID_HANDLE;

        // --- RSA Operations ---
        std::cout << "[Thread " << thread_id << "] Generating RSA key pair (2048-bit)..." << std::endl;
        auto rsa_key_pair = manager.generate_rsa_key_pair_on_token(
            slot_id, rsa_public_key_id, rsa_private_key_id, 2048);
        hRsaPublicKey = rsa_key_pair.first;
        hRsaPrivateKey = rsa_key_pair.second;
        std::cout << "[Thread " << thread_id << "] RSA Key Pair generated. Public: " << hRsaPublicKey << ", Private: " << hRsaPrivateKey << std::endl;

        // Data for RSA signing/encryption
        std::string rsa_message_str = "RSA message from thread " + std::to_string(thread_id) + ". This is a test for signing and encryption.";
        std::vector<CK_BYTE> rsa_data(rsa_message_str.begin(), rsa_message_str.end());

        // 1. RSA Sign Data
        std::cout << "[Thread " << thread_id << "] Signing RSA data..." << std::endl;
        std::vector<CK_BYTE> rsa_signature = manager.sign_data_on_token(
            slot_id, hRsaPrivateKey, rsa_data);
        std::cout << "[Thread " << thread_id << "] RSA Data signed. Signature size: " << rsa_signature.size() << " bytes." << std::endl;

        // 2. RSA Verify Signature
        std::cout << "[Thread " << thread_id << "] Verifying RSA signature..." << std::endl;
        bool rsa_verified = manager.verify_signature_on_token(
            slot_id, hRsaPublicKey, rsa_data, rsa_signature);
        if (rsa_verified) {
            std::cout << "[Thread " << thread_id << "] RSA Signature VERIFIED successfully!" << std::endl;
        } else {
            std::cerr << "[Thread " << thread_id << "] RSA Signature verification FAILED!" << std::endl;
        }

        // 3. RSA Encrypt Data
        // Note: RSA encryption has a size limit based on the key size and padding.
        // For 2048-bit RSA with PKCS#1 v1.5 padding, max plaintext is 2048/8 - 11 = 256 - 11 = 245 bytes.
        std::string rsa_plaintext_str = "RSA Encrypt test from thread " + std::to_string(thread_id) + ". Max length for 2048-bit RSA PKCS#1 v1.5 is 245 bytes.";
        if (rsa_plaintext_str.length() > 245) {
            rsa_plaintext_str = rsa_plaintext_str.substr(0, 245);
        }
        std::vector<CK_BYTE> rsa_plaintext(rsa_plaintext_str.begin(), rsa_plaintext_str.end());

        std::cout << "[Thread " << thread_id << "] Encrypting RSA data (plaintext size: " << rsa_plaintext.size() << ")..." << std::endl;
        std::vector<CK_BYTE> rsa_ciphertext = manager.encrypt_rsa_data_on_token(
            slot_id, hRsaPublicKey, rsa_plaintext);
        std::cout << "[Thread " << thread_id << "] RSA Data encrypted. Ciphertext size: " << rsa_ciphertext.size() << " bytes." << std::endl;

        // 4. RSA Decrypt Data
        std::cout << "[Thread " << thread_id << "] Decrypting RSA data..." << std::endl;
        std::vector<CK_BYTE> rsa_decrypted_plaintext = manager.decrypt_rsa_data_on_token(
            slot_id, hRsaPrivateKey, rsa_ciphertext);
        std::cout << "[Thread " << thread_id << "] RSA Data decrypted. Decrypted plaintext size: " << rsa_decrypted_plaintext.size() << " bytes." << std::endl;

        // 5. Verify RSA Decryption
        if (rsa_plaintext == rsa_decrypted_plaintext) {
            std::cout << "[Thread " << thread_id << "] RSA Decryption VERIFIED: Original and decrypted plaintext match!" << std::endl;
            std::cout << "[Thread " << thread_id << "] Original: '" << rsa_plaintext_str << "'" << std::endl;
            std::cout << "[Thread " << thread_id << "] Decrypted: '" << ckbyte_vec_to_string(rsa_decrypted_plaintext) << "'" << std::endl;
        } else {
            std::cerr << "[Thread " << thread_id << "] RSA Decryption FAILED: Original and decrypted plaintext DO NOT match!" << std::endl;
            std::cerr << "[Thread " << thread_id << "] Original: '" << rsa_plaintext_str << "'" << std::endl;
            std::cerr << "[Thread " << thread_id << "] Decrypted: '" << ckbyte_vec_to_string(rsa_decrypted_plaintext) << "'" << std::endl;
        }

        // --- AES Operations ---
        std::cout << "\n[Thread " << thread_id << "] Generating AES key (256-bit)..." << std::endl;
        hAesKey = manager.generate_aes_key_on_token(slot_id, aes_key_id, 256);
        std::cout << "[Thread " << thread_id << "] AES Key generated: " << hAesKey << std::endl;

        // Data for AES encryption/decryption
        std::string aes_plaintext_str = "AES secret message from thread " + std::to_string(thread_id) + ". This can be much longer than RSA plaintext.";
        std::vector<CK_BYTE> aes_plaintext(aes_plaintext_str.begin(), aes_plaintext_str.end());
        // Ensure plaintext is padded to a multiple of AES block size (16 bytes) if not already.
        // SoftHSMv2's CKM_AES_CBC usually handles padding (PKCS#7/PKCS#5) automatically.
        size_t padding_needed = 16 - (aes_plaintext.size() % 16);
        if (padding_needed != 16) { // If not already a multiple of 16
            aes_plaintext.insert(aes_plaintext.end(), padding_needed, static_cast<CK_BYTE>(padding_needed));
        }

        std::vector<CK_BYTE> aes_iv = generate_random_iv(16); // AES CBC requires a 16-byte IV

        // 6. AES Encrypt Data
        std::cout << "[Thread " << thread_id << "] Encrypting AES data (plaintext size: " << aes_plaintext.size() << ")..." << std::endl;
        std::vector<CK_BYTE> aes_ciphertext = manager.encrypt_aes_data_on_token(
            slot_id, hAesKey, aes_plaintext, aes_iv);
        std::cout << "[Thread " << thread_id << "] AES Data encrypted. Ciphertext size: " << aes_ciphertext.size() << " bytes." << std::endl;

        // 7. AES Decrypt Data
        std::cout << "[Thread " << thread_id << "] Decrypting AES data..." << std::endl;
        std::vector<CK_BYTE> aes_decrypted_padded_plaintext = manager.decrypt_aes_data_on_token(
            slot_id, hAesKey, aes_ciphertext, aes_iv);
        std::cout << "[Thread " << thread_id << "] AES Data decrypted. Decrypted padded plaintext size: " << aes_decrypted_padded_plaintext.size() << " bytes." << std::endl;

        // Remove PKCS#7 padding if present
        std::vector<CK_BYTE> aes_decrypted_plaintext;
        if (!aes_decrypted_padded_plaintext.empty()) {
            CK_BYTE last_byte = aes_decrypted_padded_plaintext.back();
            if (last_byte > 0 && last_byte <= 16 && aes_decrypted_padded_plaintext.size() >= last_byte) {
                // Check if all padding bytes are correct
                bool valid_padding = true;
                for (size_t i = 0; i < last_byte; ++i) {
                    if (aes_decrypted_padded_plaintext[aes_decrypted_padded_plaintext.size() - 1 - i] != last_byte) {
                        valid_padding = false;
                        break;
                    }
                }
                if (valid_padding) {
                    aes_decrypted_plaintext.assign(aes_decrypted_padded_plaintext.begin(), aes_decrypted_padded_plaintext.end() - last_byte);
                } else {
                    aes_decrypted_plaintext = aes_decrypted_padded_plaintext; // Invalid padding, keep as is
                }
            } else {
                aes_decrypted_plaintext = aes_decrypted_padded_plaintext; // No padding or invalid padding value
            }
        }


        // 8. Verify AES Decryption
        if (string_to_ckbyte_vec(aes_plaintext_str) == aes_decrypted_plaintext) { // Compare with original unpadded string
            std::cout << "[Thread " << thread_id << "] AES Decryption VERIFIED: Original and decrypted plaintext match!" << std::endl;
            std::cout << "[Thread " << thread_id << "] Original: '" << aes_plaintext_str << "'" << std::endl;
            std::cout << "[Thread " << thread_id << "] Decrypted: '" << ckbyte_vec_to_string(aes_decrypted_plaintext) << "'" << std::endl;
        } else {
            std::cerr << "[Thread " << thread_id << "] AES Decryption FAILED: Original and decrypted plaintext DO NOT match!" << std::endl;
            std::cerr << "[Thread " << thread_id << "] Original: '" << aes_plaintext_str << "'" << std::endl;
            std::cerr << "[Thread " << thread_id << "] Decrypted: '" << ckbyte_vec_to_string(aes_decrypted_plaintext) << "'" << std::endl;
        }


        // --- Hashing Operation ---
        std::string hash_message_str = "Data to hash from thread " + std::to_string(thread_id);
        std::vector<CK_BYTE> data_to_hash(hash_message_str.begin(), hash_message_str.end());

        // 9. Hash Data (SHA-256)
        std::cout << "\n[Thread " << thread_id << "] Hashing data (SHA-256)..." << std::endl;
        std::vector<CK_BYTE> hash_result = manager.hash_sha256_data_on_token(slot_id, data_to_hash);
        std::cout << "[Thread " << thread_id << "] SHA-256 Hash: " << utils::bytes_to_hex(hash_result) << " (Length: " << hash_result.size() << " bytes)" << std::endl;


        // --- Key Cleanup ---
        std::cout << "\n[Thread " << thread_id << "] Starting key cleanup..." << std::endl;
        // Find and destroy keys by ID to ensure cleanup even if handles were lost
        CK_OBJECT_HANDLE found_rsa_priv_key = manager.find_object_by_id(slot_id, rsa_private_key_id);
        if (found_rsa_priv_key != CK_INVALID_HANDLE) {
            std::cout << "[Thread " << thread_id << "] Destroying found RSA private key..." << std::endl;
            manager.destroy_object_on_token(slot_id, found_rsa_priv_key);
        }

        CK_OBJECT_HANDLE found_rsa_pub_key = manager.find_object_by_id(slot_id, rsa_public_key_id);
        if (found_rsa_pub_key != CK_INVALID_HANDLE) {
            std::cout << "[Thread " << thread_id << "] Destroying found RSA public key..." << std::endl;
            manager.destroy_object_on_token(slot_id, found_rsa_pub_key);
        }

        CK_OBJECT_HANDLE found_aes_key = manager.find_object_by_id(slot_id, aes_key_id);
        if (found_aes_key != CK_INVALID_HANDLE) {
            std::cout << "[Thread " << thread_id << "] Destroying found AES key..." << std::endl;
            manager.destroy_object_on_token(slot_id, found_aes_key);
        }

    } catch (const pkcs11::PKCS11Exception& e) {
        std::cerr << "[Thread " << thread_id << "] PKCS#11 Error: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "[Thread " << thread_id << "] General Error: " << e.what() << std::endl;
    }

    // Ensure thread-local session is closed when thread finishes its work
    manager.close_thread_local_session();
    std::cout << "--- Thread " << thread_id << ": Crypto operations finished. ---" << std::endl;
}

int main() {
    std::cout << "PKCS#11 Crypto Application Professional Example" << std::endl;
    std::cout << "PKCS#11 Library Path: " << PKCS11_LIB_PATH << std::endl;
    std::cout << "User PIN: " << USER_PIN << " (WARNING: Hardcoded for demo, insecure for production)" << std::endl;

    try {
        crypto::CryptoManager manager(PKCS11_LIB_PATH, USER_PIN);

        CK_SLOT_ID slot_id = manager.get_first_slot_id();

        // --- Single-threaded example ---
        std::cout << "\n==================================================" << std::endl;
        std::cout << "           Running Single-Threaded Operation" << std::endl;
        std::cout << "==================================================" << std::endl;
        run_crypto_operations(manager, slot_id, 0);

        // --- Multi-threaded example ---
        std::cout << "\n==================================================" << std::endl;
        std::cout << "           Running Multi-Threaded Operations" << std::endl;
        std::cout << "==================================================" << std::endl;
        const int NUM_THREADS = 2; // You can increase this for more concurrency
        std::vector<std::thread> threads;

        for (int i = 1; i <= NUM_THREADS; ++i) {
            threads.emplace_back(run_crypto_operations, std::ref(manager), slot_id, i);
        }

        for (auto& t : threads) {
            if (t.joinable()) {
                t.join();
            }
        }

        std::cout << "\nAll threads completed." << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "\nApplication Error: " << e.what() << std::endl;
        return 1;
    }

    std::cout << "\nApplication finished successfully." << std::endl;
    return 0;
}